## 一、Vue是什么

#### Vue是一个用于构建用户界面的渐进式框架

- 构建用户界面：基于数据渲染出用户看到的页面
- 渐进式：循序渐进
- 框架：一套完整的项目解决方案

#### Vue的两种使用方式

- Vue核心包开发：局部模块改造
- Vue核心包&Vue插件工程化开发：整站开发

## 二、创建Vue实例

- 构建用户界面
- 创建Vue实例，初始化渲染
  - 准备容器
  - 引包（官网）-开发版本 / 生产版本
  - 创建Vue实例  `new Vue()`
  - 指定配置项 - 渲染数据
    - `el` 指定挂载点
    - `data` 提供数据

## 三、插值表达式

是一种Vue模板语法，利用表达式进行插值，渲染到页面中。

注意点：

- 使用的数据必须存在（data）
- 支持的是表达式，而非语句，比如：if  for
- 不能在标签属性中使用{{ }}插值

## 四、Vue核心特性：响应式

==数据的响应式处理== -> 响应式：==数据变化，视图自动更新==

如何访问或者修改

- 访问数据："实例.属性名"
- 修改数据："实例.属性名" = "值"

## 五、Vue指令

带有==v-前缀==的特殊==标签属性==

### v-show

1. 作用： 控制元素显示隐藏

2. 语法： v-show = "表达式" 表达式值 true 显示， false 隐藏

3. 原理： 切换 `display: none` 控制显示隐藏

4. 场景： 频繁切换显示隐藏的场景

### v-if

1. 作用： 控制元素显示隐藏（条件渲染）

2. 语法： v-if = "表达式" 表达式值 true 显示， false 隐藏

3. 原理： 基于条件判断，是否 创建 或 移除 元素节点

4. 场景： 要么显示，要么隐藏，不频繁切换的场景

### v-else v-else-if

1. 作用： 辅助 v-if 进行判断渲染

2. 语法： v-else v-else-if = "表达式"

3. 注意： 需要紧挨着 v-if 一起使用

### v-on

1. 作用：注册事件 = ==添加监听 + 提供处理逻辑==

2. 语法：

   ① v-on:事件名 = "内联语句"

   ② v-on:事件名 = "methods中的函数名"

3. 简写：==@事件名==

4. 注意：methods函数内的 this 指向 Vue 实例

### v-bind

1. 作用： 动态的设置html的==标签属性== → src   url   title ... 

2. 语法： ==v-bind:属性名="表达式"==

3. 注意： 简写形式  ==:属性名="表达式"==

### v-for

1. 作用： 基于数据循环， 多次渲染整个元素 → 数组、对象、数字...

2. 遍历数组语法：

   v-for = "(==item, index==) in 数组"

   ① item：每一项， index：下标

   ② 省略 index: v-for = "==item in 数组=="

### v-for 中的 key

1. 语法：key属性 = "唯一标识"

2. 作用：给列表项添加的==唯一标识==。便于Vue进行列表项的==正确排序复用==。

3. 不加 key，v-for 的默认行为会尝试 原地修改元素 （就地复用）

4. 注意点：

   1. key 的值只能是 ==字符串== 或 ==数字类型==

   2. key 的值必须具有 ==唯一性==

   3. 推荐使用 ==id== 作为 key（唯一），不推荐使用 ==index== 作为 key（会变化，不对应）

5. filter 过滤 覆盖修改原数组

### v-model

1. 作用: 给 ==表单元素== 使用, ==双向数据绑定== → 可以快速 ==获取 或 设置== 表单元素内容

   ① 数据变化 → 视图自动更新

   ② 视图变化 → 数据自动更新

2. 语法: v-model = '变量'

3. unshift 修改原数组添加

## 六、指令修饰符

通过 "." 指明一些指令 ==后缀==，不同 ==后缀== 封装了不同的处理操作 → 简化代码

### ① 按键修饰符

@keyup.enter  → 键盘回车监听

### ② v-model修饰符

v-model.trim → 去除首尾空格

v-model.number → 转数字

### ③ 事件修饰符

@事件名.stop → 阻止冒泡

@事件名.prevent → 阻止默认行为

## 七、v-bind对于样式操作的增强

### ① 操作class类名

​	语法 :class = "对象/数组"

-  对象 → 键就是类名，值是布尔值。如果值为 true，有这个类，否则false没有这个类。
  - 适用场景：一个类名，来回切换。

- 数组 → 数组中所有的类，都会添加到盒子上，本质就是一个 class 列表。
  - 适用场景：批量添加或删除类。

### ② 操作style行内样式

- 语法 :style = "样式对象"
- 适用场景：某个具体属性的动态设置

## 八、computed计算属性

### 1. 基础语法

概念：基于==现有的数据==，计算出来的==新属性==。 依赖的数据变化，自动重新计算。

语法：

① 声明在 ==computed 配置项==中，一个计算属性对应一个函数

② 使用起来和普通属性一样使用 {{ ==计算属性名== }}

计算属性 → 可以将一段 ==求值的代码== 进行封装

### 2. computed计算属性 vs methods方法

**computed 计算属性：**

**作用：**封装了一段对于==数据==的处理，求得一个==结果==。

**语法：**

① 写在 ==computed== 配置项中

② 作为属性，直接使用 → ==this.计算属性== {{ ==计算属性== }}

**methods 方法：**

**作用：**给实例提供一个==方法==，调用以处理==业务逻辑==。

**语法：**

① 写在 ==methods== 配置项中

② 作为方法，需要调用 → ==this.方法名( )== {{ ==方法名()== }} @事件名="==方法名=="

==**缓存特性**（提升性能）==：

计算属性会对计算出来的==结果缓存==，再次使用直接读取缓存，

依赖项变化了，会==自动==重新计算 → 并==再次缓存==

### 3. 完整写法

```
computed: {
	计算属性名: {
		get() {
			一段代码逻辑（计算逻辑）
			return 结果
		},
		set(修改的值) {
		一段代码逻辑（修改逻辑）
		}
	}
}
```

## 九、watch侦听器（监视器）

作用：监视数据变化，执行一些 业务逻辑 或 异步操作。

语法：

### ① 简单写法

简单类型数据，直接监视

```
data: { 
    words: '苹果',
    obj: {
    	words: '苹果'
    }
},
watch: {
    // 该方法会在数据变化时，触发执行
    数据属性名 (newValue, oldValue) {
    	一些业务逻辑 或 异步操作。
    },
    '对象.属性名' (newValue, oldValue) {
    	一些业务逻辑 或 异步操作。
    }
}
```

### ② 完整写法

添加额外配置项

(1)` deep: true` 对复杂类型深度监视

```
data: {
    obj: {
        words: '苹果',
        lang: 'italy'
    },
},
watch: {// watch 完整写法
    数据属性名: {
        deep: true, // 深度监视
        handler (newValue) {
        	console.log(newValue)
        }
    }
}
```

(2) `immediate: true` 初始化立刻执行一次handler方法

```
data: {
    obj: {
        words: '苹果',
        lang: 'italy'
    },
},
watch: {// watch 完整写法
    数据属性名: {
        deep: true, // 深度监视
        immediate: true, // 是否立刻执行一次handler
        handler (newValue) {
        	console.log(newValue)
        }
    }
}
```

